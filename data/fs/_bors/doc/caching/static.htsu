#created 10.10.2011 17:53

Статические кеширование
=======================

При сохранении любого объекта на диск в виде обычного HTML возникает
ситуация, когда этот кеш нужно удалять в связи с обновлением объекта.

Проблемы появляются тогда, когда объект у нас зависит от других объектов.
Например, список топиков форума зависит от изменения топиков (появление новых,
переименование имеющихся, ответы в топики, меняющие число сообщений, отображающихся
на форуме и т.п.). Зависимости могут быть и более сложными. Удаляется сообщение
топика → обновляется топик → обновляется форум → обновляется категория форумов…

Это случай, когда изменяемый объект знает о тех объектах, что зависят от него.

Ситуация может быть ещё более сложной. Мы вводим объект «блог», выводящий
все первые записи новых топиков. Но топики форума не модифицируем искусственно,
они про блоги ничего не знают. Таким образом, нужно как-то указать системе,
что блоги должны обновляться при изменении топиков средствами блогов, при создании
их статического кеша.

Первая проблема реализована без изысков. Каждый объект может вернуть метод
{{{php cache_children()}}}, в котором перечислены объекты, кеш которых должен быть
сброшен при модификации нашего объекта. То есть у сообщения форума в
{{{php cache_children()}}} будет указан топик форума. У топика форума — объект форума
а так далее.

Рассмотрим примеры
------------------

1. Мы добавляем новое сообщение на форум, привязывая его к имеющемуся топику. Запускаем
пересчёт числа ответов в топике (или просто увеличиваем его на 1), при этом объект «топик»
меняется, его кеш сбрасывается автоматически. При изменении числа сообщений в топике, понятно,
меняется и число сообщений на форуме. Топик это знает и запускает пересчёт или инкремент для форума.
Форум обновляется, кеш сбрасывается. Вся цепочка очищается автоматически, без явного указания кешей.

2. У пользователя есть отдельная сущность, «отзывы». Страница с профилем пользователя показывает
несколько последних отзывов от отругих пользователей. Нужно сбросить её кеш при появлении новых записей.
Укажем для класса «отзыв» {{{php function cache_children() { return array($this->user()); } }}}.
То есть вернём массив с одним элементом, где будет записан класс пользователя.
При изменении числа отзывов будет загружен также объект пользователя и сброшен его статический кеш.
Поскольку объект пользователя не менялся, дальше изменений по цепочке не будет.

3. На странице списка пользователей выводится последний отзыв о пользователе. В предыдущем примере сказано,
что поскольку объект пользователя при добавлении отзыва не меняется, то по цепочке никаких очисток кешей
дальше не будет. Что делать? У объекта «список пользователей» указываем
{{{php function cache_parents() { return $this->user_last_comments(); } }}} — возвращаем список всех
последниех отзывов о пользователях (он всё равно нам нужен для вывода этих отзывов).
Система, при создании статической странички со списком, внесёт в базу данных привязки текущего
объекта и его «кеш-родителей» и при изменении последних, достав из базы данных привязки, очистит кеши
связанных страниц.

Методы и последовательности вызовов при очистке
-----------------------------------------------

Метод {{{php cache_clean_self()}}} занимается очисткой текущего объекта
и только него. По умлочанию — это удаление всех, связанных с объектом
рарегистрированных статических файлов. Можно переопределять этот метод
у себя для дополнительной обработки. Например, удалять не регестированные
вспомогательные файлы и т.п.

Метод {{{php cache_clean()}}} вызывает цепочку очисток всех связанных
объектов, вызывая для каждого из них {{{php cache_clean_self()}}}. Этот
метод вызывается в самом конце метода сохранения объекта {{{php store()}}}.
В общем случае не рекомендуется переопределять этот метод. Лучше пользоваться
штатными возможностями указания связей.

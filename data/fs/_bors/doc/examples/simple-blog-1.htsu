#nav_name блог
#create_time 01.09.2011 19:23

Уроки: Пишем простейший блог. Часть 1
=====================================

Задача
------

Формулируем задание. Простейший блог — это серия заметок пользователя, без комментариев,
без календаря, с разбивкой на страницы. В качестве бэкенда во избежание проблем
с авторизацией задействуем sqlite в виде один файл — одна таблица блоговых записей.
Да и, вообще, sqlite-бэкенд самый последний и несёт меньше всего лишних,
нужный для поддержки legacy сущностей, так что для первичного ознакомления
с него начинать удобнее.

Назовём наш проект, скажем, *exsiblo* (акроним example simple blog, в виде,
не находящимся в Гугле). В упрощённом варианте будем считать, что никаких средств
авторизации нет. Писать может любой желающий. Устраним этот момент в следующих уроках.

Работать блог будет на сайте wrk.ru, корень которого находится в каталоге
/var/www/wrk.ru/htdocs. Каталог BORS_SITE, в котором обычно лежит, собственно,
код сайта, будет использован по умолчанию «bors-site», на один уровень
выше корня, то есть /var/www/wrk.ru/bors-site.

Это одна из особенностей фрейморка — избегать хранение рабочего кода
в корне сайта. Естественно, что в своём случае вы можете хранить пример
где угодно, просто соответственным образом меняйте примеры.

Объекты
-------

Очевидно, что, как миниум, среди объектов должны быть собственно запись блога,
пусть это будут объекты класса *exsiblo_blog*. Нужно также чем-то выводить
список записей блога, пусть этим занимается класс *exsiblo_main*. Наконец,
полезно иметь пермалинки, по которым будет показываться отдельная запись.
Этим (показом себя) может заниматься и сам класс блоговой записи, но правильнее
поручить это отдельному классу представления, *exsiblo_view*.

exsiblo_blog
------------

Какие нас интересуют поля в блоговой записи. Ну, очевидно, это:
 • Заголовок записи, *title*. Название традиционное для BORS©, у каждого объекта есть тот или иной title, собственный или системный.
 • Текст записи, *source*. source — традиционное название, так как почти всегда нужно потом транслировать во что-то ещё, например, в html.
 • Дата записи, *create_time*. Стандартное название, есть почти у каждого хранимого объекта.
 • ID записи, *id*. id в общем случае не обязателен, но обычно сильно упрощает жизнь.

В BORS© разрабатываетя (и даже интенсивно используется) несколько методов автоматизации
создания классов, но все они находятся на ранних стадиях разработки и «сделаны на коленке под себя»,
так что пока создадим нужный класс вручную. Заодно будет понятнее, как оно устроено. Итак,
расположим в нашем BORS_SITE файл *classes/exsiblo/blog.php* такого содержания:
[code=php]
<?php

class exsiblo_blog extends bors_object_sqlite
{
	function table_fields()
	{
		return array(
			'id',
			'title',
			'source' => array('type' => 'bbcode'),
			'create_time' => array('type' => 'timestamp'),
		);
	}

	function html() { return lcml_bbh($this->source()); }
}
[/code]

В общем случае нужно указывать свойства *db_name()* (в случае sqlite — имя файла) и *table_name()*
— имя таблицы. Но если они не указаны, то сгенерируются автоматически. В качестве файла
будет выбран [b]BORS_SITE/data/db/{имя_проекта}.sqlite[/b], где {имя_проекта} — первое слово класса
(в нашем случае это будет [b]/var/www/wrk.ru/bors-site/data/db/exsiblo.sqlite[/b]),
в качестве имени таблицы — последнее слово имени класса во множественном числе,
т.е. [b]exsiblo_blog[/b] → [b]blogs[/b].

При сохранении первой же записи, при необходимости будет создана БД и таблица в соответствии с описаниями полей:
 • Тип *bbcode* подразумевает TEXT-поле. В отличие от типа *text*, этот тип в автоматической админке будет снабжён простым редактором BB-code. Больше принципиальных отличий нет. Хотя в перспективах можно автоматизировать метод *html()*.
 • Тип *timestamp* подразумевает хранение в БД таблицы в виде unixtime и в этом же формате — хранение в прочитанном значении объекта. 
 • *id* автоматически определяется как первичный автоинкрементный целочисленный беззнаковый ключ.
 • *title* никак не определяется, в этом случае создаётся ячейка в виде строки длиной 255 символов (VARCHAR(255)).

Метод {{{php html()}}} рассмотрим позже.

Ну, с самим классом, вроде бы, всё.

Тестируем exsiblo_blog: создание новых объектов
-----------------------------------------------

Пока нет ни админки, ни даже самого сайта, но из командной строки на PHP мы можем уже
пощупать то, что получилось. Создадим тестовую запись. Для этого создайте файл
*BORS_SITE/cli/test-blog-create.php* такого содержания (комментарии в коде для удобства, можно
их в тест не копипастить :) ):
[code=php]
<?php

// Подключаем всю BORS-инфраструктуру
require_once 'init.php';

// Создаём новый объект.
// Поле create_time заполнится автоматически

bors_new('exsiblo_blog', array(
	'title' => "Тест",
	'source' => "Тестовая запись. [i]Можно с [b]bb[/b]-разметкой[/i]",
));

// Попробуем загрузить его из базы данных.
// Ищем самую свежую запись, сортируя по времени создания в обратном порядке

$blog = bors_find_first('exsiblo_blog', array(
	'order' => '-create_time',
));

// Выводим информацию о найденном:
echo 'Object='.$blog->debug_title().PHP_EOL;
[/code]

После выполнения нашего скрипта получим созданную базу данных и вывод:
{{{
Object='Тест' exsiblo_blog(1)
}}}

Метод *debug_title()* печатает заголовок объекта, имя класса и ID объекта. Поскольку у нас первый созданный объект, то
и ID=1. Если запускать скрипт ещё и ещё, ID новых объектов будут автоинкрементироваться.

Тестируем exsiblo_blog: изменение объектов
-------------------------------------------

Создаём скрипт *BORS_SITE/cli/test-blog-change.php*:
[code=php]
<?php

// Подключаем всю BORS-инфраструктуру
require_once 'init.php';

// Загружаем самую свежую запись блога.
$blog = bors_find_first('exsiblo_blog', array(
	'order' => '-create_time',
));

// Выводим старый заголовок:
echo $blog->title().PHP_EOL;

// Меняем её заголовок на новый, включающий время:
$blog->set_title('Тест от '.date('r'));
[/code]

Всё. Больше можно ничего не делать. По окончанию работы фреймворк автоматически
сохранит все изменённые значения и при следующем запуске этого же скрипта мы увидим
новый заголовок.

Фреймворк перехватывает по {{{php __call()}}} все неописанные методы и, если видит
в начале префикс *set_*, то дальнейшую часть считает именем сохраняемого свойства,
которому и приписывает указанное значение. Также есть второй, не обязательный
параметр — флаг автосохранения изменённых данных в БД. По умолчанию он равен
{{{php true}}} и это значение используется в подавляющем большинстве случаев. Очень редко нужно
изменить значение параметра так, чтобы оно не сохранилось в БД, тогда его можно
указать явно: {{{php $blog->set_title('Не сохраняемое изменение', false);}}}.

Указать таким образом можно любые параметры, не только описанные в {{{php table_fields()}}},
но только описанные там сохранятся в базе данных по завершении работы:
{{{php $blog->set_blah_blah_blah('Это значение не сохранится в БД');}}}

На [../simple-blog-2/ следующем уроке] рассмотрим создание страницы вывода
записей нашего блога. [../simple-blog-2/ Читать дальше »»»]

// 01.09.2011 19:23
// Обсудить материал и задать вопросы можно на [http://balancer.ru/support/2011/09/t82982--urok-1-prostejshij-blog-na-sqlite-bekende.779.html соответствующей теме форума].

#nav_name блог

Уроки: Пишем простейший блог
============================

Задача
------

Формулируем задание. Простейший блог — это серия заметок пользователя, без комментариев,
без календаря, с разбивкой на страницы. В качестве бэкенда во избежание проблем
с авторизацией задействуем sqlite в виде один файл — одна таблица блоговых записей.
Да и, вообще, sqlite-бэкенд самый последний и несёт меньше всего лишних,
нужный для поддержки legacy сущностей, так что для первичного ознакомления
с него начинать удобнее.

Назовём наш проект, скажем, *exsiblo* (акроним example simple blog, в виде,
не находящимся в Гугле). В упрощённом варианте будем считать, что никаких средств
авторизации нет. Писать может любой желающий. Устраним этот момент в следующих уроках.

Работать блог будет на сайте wrk.ru, корень которого находится в каталоге
/var/www/wrk.ru/htdocs. Каталог BORS_SITE, в котором обычно лежит, собственно,
код сайта, будет использован по умолчанию «bors-site», на один уровень
выше корня, то есть /var/www/wrk.ru/bors-site.

Это одна из особенностей фрейморка — избегать хранение рабочего кода
в корне сайта. Естественно, что в своём случае вы можете хранить пример
где угодно, просто соответственным образом меняйте примеры.

Объекты
-------

Очевидно, что, как миниум, среди объектов должны быть собственно запись блога,
пусть это будут объекты класса *exsiblo_blog*. Нужно также чем-то выводить
список записей блога, пусть этим занимается класс *exsiblo_main*. Наконец,
полезно иметь пермалинки, по которым будет показываться отдельная запись.
Этим (показом себя) может заниматься и сам класс блоговой записи, но правильнее
поручить это отдельному классу представления, *exsiblo_view*.

exsiblo_blog
------------

Какие нас интересуют поля в блоговой записи. Ну, очевидно, это:
 • Заголовок записи, *title*. Название традиционное для BORS©, у каждого объекта есть тот или иной title, собственный или системный.
 • Текст записи, *source*. source — традиционное название, так как почти всегда нужно потом транслировать во что-то ещё, например, в html.
 • Дата записи, *create_time*. Стандартное название, есть почти у каждого хранимого объекта.
 • ID записи, *id*. id в общем случае не обязателен, но обычно сильно упрощает жизнь.

В BORS© разрабатываетя (и даже интенсивно используется) несколько методов автоматизации
создания классов, но все они находятся на ранних стадиях разработки и «сделаны на коленке под себя»,
так что пока создадим нужный класс вручную. Заодно будет понятнее, как оно устроено. Итак,
расположим в нашем BORS_SITE файл *classes/exsiblo/blog.php* такого содержания:
[code=php]
<?php

class exsiblo_blog extends bors_object_sqlite
{
	function table_fields()
	{
		return array(
			'id',
			'title',
			'source' => array('type' => 'bbcode'),
			'create_time' => array('type' => 'timestamp'),
		);
	}
}
[/code]

В общем случае нужно указывать свойства *db_name()* (в случае sqlite — имя файла) и *table_name()*
— имя таблицы. Но если они не указаны, то сгенерируются автоматически. В качестве файла
будет выбран [b]BORS_SITE/data/db/{имя_проекта}.sqlite[/b], где {имя_проекта} — первое слово класса
(в нашем случае это будет [b]/var/www/wrk.ru/bors-site/data/db/exsiblio.sqlite[/b]),
в качестве имени таблицы — последнее слово имени класса во множественном числе,
т.е. [b]exsiblo_blog[b] → [b]blogs[/b].

При сохранении первой же записи, при необходимости будет создана БД и таблица в соответствии
с описаниями полей. Тип *bbcode* подразумевает TEXT-поле. В отличие от типа *text*,
этот тип в автоматической админке будет снабжён простым редактором BB-code. Больше
принципиальных отличий нет. Хотя в перспективах можно автоматизировать метод *html()*.

Тип *timestamp* подразумевает хранение в БД таблицы в виде unixtime и в этом же формате — хранение
в прочитанном значении объекта. 

*id* автоматически определяется как первичный автоинкрементный целочисленный беззнаковый ключ.

*title* никак не определяется, в этом случае создаётся ячейка в виде строки длиной 255 символов (VARCHAR(255)).

Ну, с самим классом, вроде бы, всё.

Тестируем exsiblo_blog
----------------------

Пока нет ни админки, ни даже самого сайта, но из командной строки на PHP мы можем уже
пощупать то, что получилось. Создадим тестовую запись. Для этого создайте файл
*BORS_SITE/cli/test-blog.php* такого содержания (комментарии в коде для удобства, можно
их в тест не копипастить :) ):
[code=php]
<?php

// Подключаем всю BORS-инфраструктуру
require_once 'init.php';

// Создаём новый объект.
// Поле create_time заполнится автоматически

bors_new('exsiblo_blog', array(
	'title' => "Тест",
	'source' => "Тестовая запись. [i]Можно с [b]bb[/b]-разметкой[/i]",
));

// Попробуем загрузить его из базы данных.
// Ищем самую свежую запись, сортируя по времени создания в обратном порядке

$blog = bors_find_first('exsiblo_blog', array(
	'order' => '-create_time',
));

// Выводим информацию о найденном:
echo 'Object='.$blog->debug_title().PHP_EOL;
[/code]

После выполнения нашего скрипта получим созданную базу данных и вывод:
{{{
Object='Тест' exsiblo_blog(8)
}}}

На этом пока возьму таймаут. Следом расскажу, как изменять объекты и
напишем простейший просмотрщик нашего блога.

// 01.09.2011б 19:23
// Обсудить материал и задать вопросы можно на [http://balancer.ru/support/2011/09/t82982--urok-1-prostejshij-blog-na-sqlite-bekende.779.html соответствующей теме форума].
